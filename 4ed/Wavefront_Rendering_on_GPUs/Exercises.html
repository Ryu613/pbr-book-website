
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="icon" href="/favicon.ico?v=2" /> <!-- force refresh -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

<script async src="https://cse.google.com/cse.js?cx=22a43cef261a245ea"></script>  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Exercises</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Wavefront_Rendering_on_GPUs.html">Wavefront Rendering on GPUs</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Exercises</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Wavefront_Rendering_on_GPUs/Further_Reading.html">(Previous: Further Reading)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<h2>Exercises</h2><p>


</p>
<p></p>
<ol>

 <li class="exercise"><span class="exerciseicon">&#9312;</span> Modify <tt>soac</tt> so that the code it generates leaves
objects in AOS layout in memory and recompile <tt>pbrt</tt>.  (You will need to
manually update a few places in the <a href="../Wavefront_Rendering_on_GPUs/Path_Tracer_Implementation.html#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a> that only
access a single field of a structure, as well.)  How is performance affected
by this change?

 <li class="exercise"><span class="exerciseicon">&#9313;</span> <tt>pbrt</tt>&rsquo;s <a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths"><tt>SampledWavelengths</tt></a> class stores two
<tt>Float</tt>s for each wavelength: one for the wavelength value and one for
its PDF. This class is passed along between almost all kernels.  Render a
scene on the GPU and work out an estimate of the amount of bandwidth
consumed in communicating these values between kernels.  (You may need to
make some assumptions to do so.)

Then, implement an alternative <tt>SOA</tt> representation for
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths"><tt>SampledWavelengths</tt></a> that stores only two values: the <tt>Float</tt>
sample used to originally sample the wavelengths and a Boolean value that
indicates whether the secondary wavelengths have been terminated.  You
might use the sign bit to encode the Boolean value, or you might even try a
16-bit encoding, with the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.91ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2114.2 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket 0 comma 1 right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-30" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="779" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="1224" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="1724" y="0"></use>
</g>
</svg> sample value quantized to 15 bits and the
16th used to indicate termination.  Write code to encode
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths"><tt>SampledWavelengths</tt></a> to this representation when they are pushed to a
queue and to decode this representation back to <tt>SampledWavelengths</tt>
when work is read from the queue via a call to
<a href="../Cameras_and_Film/Film_and_Imaging.html#Film::SampleWavelengths"><tt>Film::SampleWavelengths()</tt></a> and then possibly a call to
<a href="../Radiometry,_Spectra,_and_Color/Representing_Spectral_Distributions.html#SampledWavelengths::TerminateSecondary"><tt>SampledWavelengths::TerminateSecondary()</tt></a>.  Estimate how much
bandwidth your improved representation saves.  How is runtime performance
affected?  Can you draw any conclusions about whether your GPU is memory or
bandwidth limited when running these kernels?

 <li class="exercise"><span class="exerciseicon">&#9313;</span> The direct lighting code in the
<tt>EvaluateMaterialsAndBSDFs()</tt>
kernel may suffer from divergence in the <a href="../Light_Sources/Light_Interface.html#Light::SampleLi"><tt>Light::SampleLi()</tt></a> call
if the scene has a variety of types of light source.  Construct such a
scene and then experiment with moving light sampling into a separate
kernel, using a work queue to supply work to it and where the light samples
are pushed on to a queue for the rest of the direct lighting computation.
What is the effect on performance for your test scene?  Is performance
negatively impacted for scenes with just a single type of light?



 <li class="exercise"><span class="exerciseicon">&#9314;</span> Add support for ray differentials to the
<a href="../Wavefront_Rendering_on_GPUs/Path_Tracer_Implementation.html#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a>, including both generating them for camera
rays and computing updated differentials for reflected and refracted rays.
(You will likely want to repurpose the code in the implementation of the
<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a>
<tt>SpawnRay()</tt> method in
Section&nbsp;<a href="../Textures_and_Materials/Texture_Sampling_and_Antialiasing.html#sec:raydiff-reflect-transmit">10.1.3</a>.)

After ensuring that texture filtering results match <tt>pbrt</tt> running on the
CPU, measure the performance impact of your changes.  How much performance
is lost from the bandwidth used in passing ray differentials between
kernels?  Do any kernels have better performance?  If so, can you explain
why?

Next, implement one of the more space-efficient techniques for representing
derivative information with rays that are described by Akenine-M&ouml;ller
et al. (<a href="Further_Reading.html#cite:AkenineMoller2019">2019</a>).  How do performance and filtering
quality compare to ray differentials?

 <li class="exercise"><span class="exerciseicon">&#9314;</span> The <a href="../Wavefront_Rendering_on_GPUs/Path_Tracer_Implementation.html#WavefrontPathIntegrator"><tt>WavefrontPathIntegrator</tt></a>&rsquo;s performance can suffer
from scenes with very high maximum ray depths when there are few active
rays remaining at high depths and, in turn, insufficient parallelism for the
GPU to reach its peak capabilities.  One approach to address this problem
is <em>path regeneration</em>, which was described by Nov&aacute;k et
al. (<a href="Further_Reading.html#cite:Novak2010">2010</a>).

Following this approach, modify <tt>pbrt</tt> so that each ray traced handles its
termination individually when it reaches the maximum depth.  Execute a
modified camera ray generation kernel each time through the main rendering
loop so that additional pixel samples are taken and camera rays are
generated until the current <a href="../Wavefront_Rendering_on_GPUs/Path_Tracer_Implementation.html#RayQueue"><tt>RayQueue</tt></a> is filled or there are no more
samples to take.  Note that you will have to handle <a href="../Cameras_and_Film/Film_and_Imaging.html#Film"><tt>Film</tt></a> updates in a
different way than the current implementation&mdash;for example, via a work queue when
rays terminate.  You may also have to handle the case of multiple threads
updating the same pixel sample.  Finally, implement a mechanism for the GPU
to notify the CPU when all rays have terminated so that it knows when to
stop launching kernels.

With all that taken care of, measure <tt>pbrt</tt>&rsquo;s performance for a scene with a
high maximum ray depth. (Scenes that include volumetric scattering with media with very
high albedos are a good choice for this measurement.)  How much is
performance improved with your approach?  How is performance affected for
easier scenes with lower maximum depths that do not suffer from this problem?

 <li class="exercise"><span class="exerciseicon">&#9314;</span> In <tt>pbrt</tt>&rsquo;s current implementation, the wavefront path tracer
is usually slower than the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a> when running on the CPU.
Render a few scenes using both approaches and benchmark <tt>pbrt</tt>&rsquo;s
performance.  Are any opportunities to improve the performance of the
wavefront approach on the CPU evident?

Next, measure how performance changes as you increase or decrease the queue
sizes (and consequently, the number of pixel samples that are evaluated in
parallel).  Performance may be suboptimal with the current value of
<a href="../Wavefront_Rendering_on_GPUs/Path_Tracer_Implementation.html#WavefrontPathIntegrator::maxQueueSize"><tt>WavefrontPathIntegrator::maxQueueSize</tt></a>, which leads to queues
much larger than can fit in the on-chip caches.  However, too small a queue size may
offer insufficient parallelism or may lead to too little work being done in
each <a href="../Utilities/Parallelism.html#ParallelFor"><tt>ParallelFor()</tt></a> call, which may also hurt performance.  Are there
better default queue sizes for the CPU than the ones used currently?

 <li class="exercise"><span class="exerciseicon">&#9314;</span> When the <tt>WavefrontPathIntegrator</tt> runs on the CPU,
there is currently minimal performance benefit from organizing work in
queues.  However, the queues offer the possibility of making it easier to
use SIMD instructions on the CPU: kernels might remove 8 work items at a
time, for example, processing them together using the 8 elements of a
256-bit SIMD register.  Implement this approach and investigate <tt>pbrt</tt>&rsquo;s
performance.  (You may want to consider using a language such as
<tt>ispc</tt> (<a href="Further_Reading.html#cite:Pharr2012">Pharr and Mark 2012</a>) to avoid the challenges of manually writing
code using SIMD intrinsics.)

 <li class="exercise"><span class="exerciseicon">&#9314;</span> Implement a GPU ray tracer that is based on <tt>pbrt</tt>&rsquo;s class
implementations from previous chapters but uses the GPU&rsquo;s ray-tracing API for
scheduling rendering work instead of the wavefront-based architecture used
in this chapter.  (You may want to start by supporting only a subset of the
full functionality of the <tt>WavefrontPathIntegrator</tt>.)  Measure the
performance of the two implementations and discuss their differences.  You
may find it illuminating to use a profiler to measure the bandwidth
consumed by each implementation.  Can you find cases where the wavefront
integrator&rsquo;s performance is limited by available memory bandwidth but yours
is not?

</ol><p>


</p>
<p>

</p>
<p>


</p>
<p>

</p>
<p>

</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
<div class="container-fluid">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>,<br>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">&copy; 2004-2023</a> Matt Pharr, Wenzel Jakob, and Greg Humphreys.
<a href="https://github.com/mmp/pbr-book-website/"><span class="fab fa-github"></span></a><br>
Purchase a printed copy: <a href="https://www.amazon.com/Physically-Based-Rendering-fourth-Implementation/dp/0262048027?keywords=physically+based+rendering+4th+edition&qid=1671730412&sprefix=physically+based%!C(MISSING)aps%!C(MISSING)145&sr=8-1&linkCode=ll1&tag=pharr-20&linkId=81a816d90f0c7e872617f1f930a51fd6&language=en_US&ref_=as_li_ss_tl"><span class="fab fa-amazon"></span></a>
<a href="https://mitpress.mit.edu/9780262048026/physically-based-rendering/"><img src="/mitpress.png" width=10 height=16></a>
</span>
</div>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Retrospective_and_the_Future.html">Retrospective and the Future</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
