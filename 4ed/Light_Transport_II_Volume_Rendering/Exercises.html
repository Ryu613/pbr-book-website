
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="icon" href="/favicon.ico?v=2" /> <!-- force refresh -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

<script async src="https://cse.google.com/cse.js?cx=22a43cef261a245ea"></script>  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Exercises</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Light_Transport_II_Volume_Rendering.html">Light Transport II: Volume Rendering</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Exercises</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Light_Transport_II_Volume_Rendering/Further_Reading.html">(Previous: Further Reading)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<h2>Exercises</h2><p>


</p>
<p></p>
<ol>

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Replace ratio tracking in the
<a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator::SampleLd"><tt>VolPathIntegrator::SampleLd()</tt></a> method with delta tracking.  After you
confirm that your changes converge to the correct result, measure the
difference in performance and MSE in order to compare the Monte Carlo
efficiency of the two approaches for a variety of volumetric data sets.  Do
you find any cases where delta tracking is more efficient?  If so, can you
explain why?

 <li class="exercise"><span class="exerciseicon">&#9313;</span> <em>Residual ratio tracking</em> can compute transmittance
more efficiently than ratio tracking in dense media; it is based on finding
lower bounds of <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.199ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 946.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">sigma Subscript normal t</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D70E" d="M567 407c0 -34 -36 -34 -49 -34h-110c31 -44 31 -92 31 -109c0 -154 -133 -275 -251 -275c-91 0 -150 70 -150 158c0 119 111 284 262 284h228c18 0 39 0 39 -24zM375 276c0 31 -8 97 -92 97c-34 0 -94 -14 -136 -83c-35 -59 -47 -141 -47 -171c0 -72 40 -108 89 -108 c39 0 93 26 132 85c34 51 54 133 54 180Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D70E" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="808" y="-213"></use>
</g>
</svg> in regions of space, analytically computing that
portion of the transmittance, and then using ratio tracking for the
remaining variation (<a href="Further_Reading.html#cite:Novak2014">Nov&aacute;k et al. 2014</a>).  Implement this approach in <tt>pbrt</tt> and measure its effectiveness.  Note that you will need to make
modifications to both the <a href="../Volume_Scattering/Media.html#Medium"><tt>Medium</tt></a>&rsquo;s <a href="../Volume_Scattering/Media.html#RayMajorantSegment"><tt>RayMajorantSegment</tt></a>
representation and the implementation of the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a> in
order to do so.

 <li class="exercise"><span class="exerciseicon">&#9313;</span> The current implementation of <a href="../Light_Transport_II_Volume_Rendering/The_Equation_of_Transfer.html#SampleT_maj"><tt>SampleT_maj()</tt></a>
consumes a new uniform random value for each <a href="../Volume_Scattering/Media.html#RayMajorantSegment"><tt>RayMajorantSegment</tt></a>
returned by the medium&rsquo;s iterator.  Its sampling operation can
alternatively be implemented using a single uniform value to sample a total
optical thickness and then finding the point along the ray where that
optical thickness has been accumulated.  Modify <tt>SampleT_maj()</tt> to
implement that approach and measure rendering performance.  Is there a
benefit compared to the current implementation?

 <li class="exercise"><span class="exerciseicon">&#9314;</span> It is not possible to directly sample emission in volumes
with the current <a href="../Volume_Scattering/Media.html#Medium"><tt>Medium</tt></a> interface.  Thus, integrators are left
to include emission only when their random walk through a medium happens to
find a part of it that is emissive.  This approach can be quite
inefficient, especially for localized bright emission.  Add methods to the
<a href="../Volume_Scattering/Media.html#Medium"><tt>Medium</tt></a> interface that allow for sampling emission and modify the
direct lighting calculation in the <a href="../Light_Transport_II_Volume_Rendering/Volume_Scattering_Integrators.html#VolPathIntegrator"><tt>VolPathIntegrator</tt></a> to use them.
For inspiration, it may be worthwhile to read the papers by Villemin and
Hery (<a href="Further_Reading.html#cite:Villemin2013">2013</a>) and Simon et&nbsp;al. (<a href="Further_Reading.html#cite:Simon2017">2017</a>) on
Monte Carlo sampling of 3D emissive volumes.  Measure the improvement in
efficiency with your approach.  Are there any cases where it hurts
performance?

 <li class="exercise"><span class="exerciseicon">&#9314;</span> While sampling distances in participating media according to
the majorant is much more effective than sampling uniformly, it does not
account for other factors that vary along the ray, such as the scattering
coefficient and phase function or variation in illumination from light
sources.  Implement the approach described by Wrenninge and Villemin
(<a href="Further_Reading.html#cite:Wrenninge2020">2020</a>) on product sampling based on adapting the
majorant to account for multiple factors in the integrand and then randomly
selecting among weighted sample points.  (You may find weighted reservoir
sampling (Section&nbsp;<a href="../Sampling_Algorithms/Reservoir_Sampling.html#sec:reservoir-sampling">A.2</a>) a useful technique to apply
in order to avoid the storage costs of maintaining the candidate samples.)
Measure the performance of your implementation as well as how much it
improves image quality for tricky volumetric scenes.

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Add the capability to specify a bump or normal map for
the bottom interface in the <a href="../Light_Transport_II_Volume_Rendering/Scattering_from_Layered_Materials.html#LayeredBxDF"><tt>LayeredBxDF</tt></a>. (The current implementation
applies bump mapping at the top interface only.)  Render images that show
the difference between perturbing the normal at the top interface and
having a smooth bottom interface and vice versa.

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Investigate the effect of improving the sampling patterns
used in the <a href="../Light_Transport_II_Volume_Rendering/Scattering_from_Layered_Materials.html#LayeredBxDF"><tt>LayeredBxDF</tt></a>&mdash;for example, by replacing the uniform random
numbers used with low-discrepancy points.  You may need to pass further
information through the BSDF evaluation routines to do so, such as the
current pixel, pixel sample, and current ray depth.  Measure how much error
is reduced by your changes as well as their performance impact.

 <li class="exercise"><span class="exerciseicon">&#9314;</span> Generalize the <a href="../Light_Transport_II_Volume_Rendering/Scattering_from_Layered_Materials.html#LayeredBxDF"><tt>LayeredBxDF</tt></a> to allow the specification
of an arbitrary number of layers with different media between them.  You
may want to review the improved sampling techniques for this case that were
introduced by Gamboa et&nbsp;al. (<a href="Further_Reading.html#cite:Gamboa2020">2020</a>). Verify that your
implementation gives equivalent results to nested application of the
<a href="../Light_Transport_II_Volume_Rendering/Scattering_from_Layered_Materials.html#LayeredBxDF"><tt>LayeredBxDF</tt></a> and measure the efficiency difference between the two
approaches.



</ol><p>


</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>


</p>
<p>


</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
<div class="container-fluid">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>,<br>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">&copy; 2004-2023</a> Matt Pharr, Wenzel Jakob, and Greg Humphreys.
<a href="https://github.com/mmp/pbr-book-website/"><span class="fab fa-github"></span></a><br>
Purchase a printed copy: <a href="https://www.amazon.com/Physically-Based-Rendering-fourth-Implementation/dp/0262048027?keywords=physically+based+rendering+4th+edition&qid=1671730412&sprefix=physically+based%!C(MISSING)aps%!C(MISSING)145&sr=8-1&linkCode=ll1&tag=pharr-20&linkId=81a816d90f0c7e872617f1f930a51fd6&language=en_US&ref_=as_li_ss_tl"><span class="fab fa-amazon"></span></a>
<a href="https://mitpress.mit.edu/9780262048026/physically-based-rendering/"><img src="/mitpress.png" width=10 height=16></a>
</span>
</div>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Wavefront_Rendering_on_GPUs.html">Wavefront Rendering on GPUs</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
